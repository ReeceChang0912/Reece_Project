尾调用

道格拉斯与阮一峰都写了一篇关于尾调用优化的文章，阮一峰秉承其一贯通俗易懂的风格，在老道讲道激活对象的时候，我开始有点懵逼，然后转向了阮一峰，欸嘿，果然回头一看，老道所讲的专业观点就轻松理解。当然在对尾调用的定义上，是老道要专业很多的。

​			` function A (){`

​				`return B()}`

​		  `function B(){`

​				`return C()} `

 我们都是道调用栈，调用帧等概念，如上，在函数A中调用了函数B,就会在其上创建一个调用记录，也就是一个调用帧来记录函数B的调用位置与其实参，以便于函数执行和执行完返回给函数A，众所周知，其实JS中并不存在调用栈这样的东西，实际上使用了一个叫做激活对象的东西，那么这个激活对象需要足够大，能够容纳实参与一些变量，之后需要把函数引用存入新的活跃对象，在执行A的过程中，调用了B的话则需要重新创建一个激活对象，然后把结果返回给A。

我们可以观察尾调用，它有几个特征：

1. 在函数的最后一步执行，与其摆放的位置无关

2. 返回的是一个函数的直接执行结果，注意直接这个词

   `return 1+b(2)`

   这就不是一个尾调用

   同样：

   `x=b(10) return x`也不是一个尾调用

从这两个特性，我们就可以发现，既然在函数的最后执行，那么这个B函数的结果返回给A，A又不能使用，那么为啥还重新开辟一个激活对象呢？我不如直接把A的激活对象创建的足够大，那么当我遇到尾调用B的时候，我直接把A设置为新的活跃对象，把B的变量与函数引用存入A的激活对象，就减少了内存分配与垃圾回收的时间，不是更好？当然这需要A的激活对象设置的足够大，如果不能存入B的情况，我们还是需要重新创建一个B的激活对象。

递归，与栈密切相关的一个思维模式，如果我们能把递归的调用放到尾调用的位置，就叫做尾递归，这就充分利用了尾调用的优势，不用担心StackOverflow。

这时候就需要对递归函数进行改造，例如阶乘函数，通常使用高阶与ES6的传一个默认参数的形式。

此外有一些情况，比如try catch不能进行尾递归优化，万一进入到catch分支，激活对象是不能被缩减的。try需要将函数控制权交给catch。

